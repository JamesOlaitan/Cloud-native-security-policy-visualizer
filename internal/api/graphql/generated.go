// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

type Config struct {
	Resolvers ResolverRoot
}

type ResolverRoot interface {
	Node() NodeResolver
	Query() QueryResolver
}

type NodeResolver interface {
	Neighbors(ctx context.Context, obj *Node, kinds []*string) ([]*Neighbor, error)
}

type QueryResolver interface {
	SearchPrincipals(ctx context.Context, query string, limit *int) ([]*Node, error)
	Node(ctx context.Context, id string) (*Node, error)
	ShortestPath(ctx context.Context, from string, to string, maxHops *int) (*Path, error)
	Findings(ctx context.Context, snapshotID string) ([]*Finding, error)
	Snapshots(ctx context.Context) ([]*Snapshot, error)
	SnapshotDiff(ctx context.Context, a string, b string) (*SnapshotDiff, error)
}

type executableSchema struct {
	resolvers ResolverRoot
}

func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers: cfg.Resolvers,
	}
}

func (e *executableSchema) Schema() *graphql.Schema {
	// Simplified stub - in real implementation, this would parse the schema
	return nil
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	return childComplexity + 1, true
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	// Simplified stub - in real implementation, this would execute queries
	return func(ctx context.Context) *graphql.Response {
		return &graphql.Response{}
	}
}

