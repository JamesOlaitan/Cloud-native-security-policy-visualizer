package graph

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/jamesolaitan/accessgraph/internal/ingest"
)

// ExportMarkdownAttackPath exports an attack path as a formatted Markdown document
func ExportMarkdownAttackPath(fromID, toID string, nodes []ingest.Node, edges []ingest.Edge) (string, error) {
	if len(nodes) == 0 {
		return "", fmt.Errorf("no nodes in path")
	}

	tmpl := `# Attack Path: {{.From}} â†’ {{.To}}

## Path Summary

**From:** ` + "`{{.From}}`" + `
**To:** ` + "`{{.To}}`" + `
**Hops:** {{.Hops}}
**Date:** {{.Date}}

## Path Details

| Step | From (Kind) | Edge | To (Kind) | Notes |
|------|-------------|------|-----------|-------|
{{range .Steps}}| {{.Step}} | {{.FromNode}} ({{.FromKind}}) | {{.EdgeKind}} | {{.ToNode}} ({{.ToKind}}) | {{.Notes}} |
{{end}}

## Risk Assessment

{{range .RiskFactors}}- {{.}}
{{end}}

## Recommendations

1. Review and restrict permissions along this path
2. Consider implementing least-privilege policies
3. Add monitoring and alerting for this access pattern
4. Review sensitive resource tagging and access controls

---
*Generated by AccessGraph v1.1.0*
`

	type Step struct {
		Step     int
		FromNode string
		FromKind string
		EdgeKind string
		ToNode   string
		ToKind   string
		Notes    string
	}

	data := struct {
		From        string
		To          string
		Hops        int
		Date        string
		Steps       []Step
		RiskFactors []string
	}{
		From: fromID,
		To:   toID,
		Hops: len(nodes) - 1,
		Date: "2025-10-08", // Could use time.Now() but keeping deterministic for tests
	}

	// Build steps
	for i := 0; i < len(nodes)-1; i++ {
		fromNode := nodes[i]
		toNode := nodes[i+1]
		edge := edges[i]

		notes := ""
		if val, ok := edge.Props["action"]; ok {
			notes = fmt.Sprintf("Action: %s", val)
		}
		if val, ok := edge.Props["cross_account"]; ok && val == "true" {
			notes += " [CROSS-ACCOUNT]"
		}

		data.Steps = append(data.Steps, Step{
			Step:     i + 1,
			FromNode: truncateID(fromNode.ID),
			FromKind: string(fromNode.Kind),
			EdgeKind: edge.Kind,
			ToNode:   truncateID(toNode.ID),
			ToKind:   string(toNode.Kind),
			Notes:    notes,
		})
	}

	// Analyze risk factors
	data.RiskFactors = analyzePathRisks(nodes, edges)

	t, err := template.New("markdown").Parse(tmpl)
	if err != nil {
		return "", fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}

	return buf.String(), nil
}

// analyzePathRisks identifies risk factors in an attack path
func analyzePathRisks(nodes []ingest.Node, edges []ingest.Edge) []string {
	var risks []string

	// Check for wildcards
	for _, edge := range edges {
		if val, ok := edge.Props["action"]; ok {
			if val == "*" || len(val) > 2 && val[len(val)-2:] == ":*" {
				risks = append(risks, "**Wildcard permissions detected** - overly permissive policy")
				break
			}
		}
	}

	// Check for cross-account access
	for _, edge := range edges {
		if val, ok := edge.Props["cross_account"]; ok && val == "true" {
			risks = append(risks, "**Cross-account access** - potential lateral movement vector")
			break
		}
	}

	// Check for sensitive target
	if len(nodes) > 0 {
		lastNode := nodes[len(nodes)-1]
		if val, ok := lastNode.Props["sensitive"]; ok && val == "true" {
			risks = append(risks, "**Sensitive resource accessed** - high-value target")
		}
	}

	// Check for admin privileges
	for _, node := range nodes {
		if node.Kind == ingest.POLICY {
			if val, ok := node.Props["name"]; ok {
				if val == "AdministratorAccess" || val == "cluster-admin" {
					risks = append(risks, "**Administrator privileges in path** - excessive access")
					break
				}
			}
		}
	}

	if len(risks) == 0 {
		risks = append(risks, "No critical risk factors detected in this path")
	}

	return risks
}

// truncateID shortens long resource IDs for display
func truncateID(id string) string {
	if len(id) <= 50 {
		return id
	}
	return id[:47] + "..."
}
