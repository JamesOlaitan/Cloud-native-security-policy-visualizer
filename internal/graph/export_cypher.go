package graph

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sort"

	"github.com/jamesolaitan/accessgraph/internal/ingest"
)

// ExportCypher exports the graph to Neo4j Cypher format with MERGE statements
func (g *Graph) ExportCypher() (string, error) {
	var buf bytes.Buffer

	// Write header comment
	buf.WriteString("// AccessGraph Neo4j Export\n")
	buf.WriteString("// Generated by AccessGraph v1.1.0\n")
	buf.WriteString("// This file contains Cypher statements to import the graph into Neo4j\n\n")

	// Create constraint for node uniqueness
	buf.WriteString("// Create constraint for node uniqueness\n")
	buf.WriteString("CREATE CONSTRAINT node_id IF NOT EXISTS FOR (n:Node) REQUIRE n.id IS UNIQUE;\n\n")

	// Create index for kind
	buf.WriteString("// Create index for kind field\n")
	buf.WriteString("CREATE INDEX node_kind_idx IF NOT EXISTS FOR (n:Node) ON (n.kind);\n\n")

	// Export nodes (sorted for determinism)
	buf.WriteString("// ========== NODES ==========\n\n")

	nodeIDs := make([]string, 0, len(g.nodes))
	for id := range g.nodes {
		nodeIDs = append(nodeIDs, id)
	}
	sort.Strings(nodeIDs)

	for _, id := range nodeIDs {
		node := g.nodes[id]

		// Build props map
		props := make(map[string]interface{})
		props["id"] = node.data.ID
		props["kind"] = string(node.data.Kind)

		// Add labels as array
		if len(node.data.Labels) > 0 {
			props["labels"] = node.data.Labels
		}

		// Merge custom props
		for k, v := range node.data.Props {
			props[k] = v
		}

		propsJSON, err := json.Marshal(props)
		if err != nil {
			return "", fmt.Errorf("marshaling node props: %w", err)
		}

		// Generate MERGE statement with kind label
		kindLabel := sanitizeLabel(string(node.data.Kind))
		buf.WriteString(fmt.Sprintf("MERGE (n:Node:K_%s {id: %s})\n",
			kindLabel,
			quoteString(node.data.ID)))
		buf.WriteString(fmt.Sprintf("SET n += %s;\n\n", string(propsJSON)))
	}

	// Export edges (sorted for determinism)
	buf.WriteString("// ========== EDGES ==========\n\n")

	// Sort edges
	edges := make([]edgeWithIndex, len(g.edges))
	for i, e := range g.edges {
		edges[i] = edgeWithIndex{edge: e, index: i}
	}
	sort.Slice(edges, func(i, j int) bool {
		if edges[i].edge.Src != edges[j].edge.Src {
			return edges[i].edge.Src < edges[j].edge.Src
		}
		if edges[i].edge.Dst != edges[j].edge.Dst {
			return edges[i].edge.Dst < edges[j].edge.Dst
		}
		return edges[i].edge.Kind < edges[j].edge.Kind
	})

	for _, e := range edges {
		edge := e.edge

		// Build props map
		props := make(map[string]interface{})
		props["kind"] = edge.Kind
		for k, v := range edge.Props {
			props[k] = v
		}

		propsJSON, err := json.Marshal(props)
		if err != nil {
			return "", fmt.Errorf("marshaling edge props: %w", err)
		}

		// Generate MATCH + MERGE for edge
		kindLabel := sanitizeLabel(edge.Kind)
		buf.WriteString(fmt.Sprintf("MATCH (a:Node {id: %s}), (b:Node {id: %s})\n",
			quoteString(edge.Src),
			quoteString(edge.Dst)))
		buf.WriteString(fmt.Sprintf("MERGE (a)-[r:K_%s]->(b)\n", kindLabel))
		buf.WriteString(fmt.Sprintf("SET r += %s;\n\n", string(propsJSON)))
	}

	return buf.String(), nil
}

// edgeWithIndex is a helper for sorting
type edgeWithIndex struct {
	edge  ingest.Edge
	index int
}

// sanitizeLabel removes invalid characters from Neo4j labels
func sanitizeLabel(label string) string {
	// Replace invalid characters with underscore
	result := ""
	for _, ch := range label {
		if (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch == '_' {
			result += string(ch)
		} else {
			result += "_"
		}
	}
	return result
}

// quoteString properly quotes a string for Cypher
func quoteString(s string) string {
	// Escape quotes and backslashes
	escaped := ""
	for _, ch := range s {
		if ch == '"' || ch == '\\' {
			escaped += "\\"
		}
		escaped += string(ch)
	}
	return fmt.Sprintf(`"%s"`, escaped)
}
