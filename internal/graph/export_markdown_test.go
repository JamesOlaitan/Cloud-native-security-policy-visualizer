package graph

import (
	"strings"
	"testing"

	"github.com/jamesolaitan/accessgraph/internal/ingest"
)

func TestExportMarkdownAttackPath(t *testing.T) {
	// Create a simple attack path
	nodes := []ingest.Node{
		{
			ID:     "arn:aws:iam::123456789012:role/DevRole",
			Kind:   ingest.KindPrincipal,
			Labels: []string{"aws", "role"},
			Props: map[string]string{
				"name": "DevRole",
			},
		},
		{
			ID:     "arn:aws:iam::123456789012:policy/DevDataAccess",
			Kind:   ingest.KindPolicy,
			Labels: []string{"aws", "policy"},
			Props: map[string]string{
				"name": "DevDataAccess",
			},
		},
		{
			ID:     "arn:aws:s3:::data-bkt",
			Kind:   ingest.KindResource,
			Labels: []string{"aws", "s3"},
			Props: map[string]string{
				"name":      "data-bkt",
				"sensitive": "true",
			},
		},
	}

	edges := []ingest.Edge{
		{
			Src:   "arn:aws:iam::123456789012:role/DevRole",
			Dst:   "arn:aws:iam::123456789012:policy/DevDataAccess",
			Kind:  "HAS_POLICY",
			Props: map[string]string{},
		},
		{
			Src:  "arn:aws:iam::123456789012:policy/DevDataAccess",
			Dst:  "arn:aws:s3:::data-bkt",
			Kind: "ALLOWS_ACCESS",
			Props: map[string]string{
				"action": "s3:GetObject",
			},
		},
	}

	markdown, err := ExportMarkdownAttackPath(
		"arn:aws:iam::123456789012:role/DevRole",
		"arn:aws:s3:::data-bkt",
		nodes,
		edges,
	)

	if err != nil {
		t.Fatalf("ExportMarkdownAttackPath failed: %v", err)
	}

	// Verify content
	expectedStrings := []string{
		"# Attack Path:",
		"## Path Summary",
		"**From:**",
		"**To:**",
		"**Hops:** 2",
		"## Path Details",
		"| Step | From (Kind) | Edge | To (Kind) | Notes |",
		"PRINCIPAL",
		"POLICY",
		"RESOURCE",
		"HAS_POLICY",
		"ALLOWS_ACCESS",
		"Action: s3:GetObject",
		"## Risk Assessment",
		"**Sensitive resource accessed**",
		"## Recommendations",
		"*Generated by AccessGraph",
	}

	for _, expected := range expectedStrings {
		if !strings.Contains(markdown, expected) {
			t.Errorf("Expected markdown to contain %q, but it didn't", expected)
		}
	}

	// Verify table has 2 rows (plus header)
	tableRows := strings.Count(markdown, "| 1 |") + strings.Count(markdown, "| 2 |")
	if tableRows != 2 {
		t.Errorf("Expected 2 steps in table, found %d", tableRows)
	}
}

func TestExportMarkdownWithWildcards(t *testing.T) {
	nodes := []ingest.Node{
		{
			ID:     "arn:aws:iam::123456789012:role/AdminRole",
			Kind:   ingest.KindPrincipal,
			Labels: []string{"aws", "role"},
			Props: map[string]string{
				"name": "AdminRole",
			},
		},
		{
			ID:     "arn:aws:iam::123456789012:policy/AdminPolicy",
			Kind:   ingest.KindPolicy,
			Labels: []string{"aws", "policy"},
			Props: map[string]string{
				"name": "AdministratorAccess",
			},
		},
		{
			ID:     "arn:aws:s3:::prod-data",
			Kind:   ingest.KindResource,
			Labels: []string{"aws", "s3"},
			Props:  map[string]string{},
		},
	}

	edges := []ingest.Edge{
		{
			Src:   "arn:aws:iam::123456789012:role/AdminRole",
			Dst:   "arn:aws:iam::123456789012:policy/AdminPolicy",
			Kind:  "HAS_POLICY",
			Props: map[string]string{},
		},
		{
			Src:  "arn:aws:iam::123456789012:policy/AdminPolicy",
			Dst:  "arn:aws:s3:::prod-data",
			Kind: "ALLOWS_ACCESS",
			Props: map[string]string{
				"action": "*",
			},
		},
	}

	markdown, err := ExportMarkdownAttackPath(
		"arn:aws:iam::123456789012:role/AdminRole",
		"arn:aws:s3:::prod-data",
		nodes,
		edges,
	)

	if err != nil {
		t.Fatalf("ExportMarkdownAttackPath failed: %v", err)
	}

	// Should detect wildcard risk
	if !strings.Contains(markdown, "**Wildcard permissions detected**") {
		t.Error("Expected to detect wildcard permissions")
	}

	// Should detect admin privileges
	if !strings.Contains(markdown, "**Administrator privileges in path**") {
		t.Error("Expected to detect administrator privileges")
	}
}

func TestExportMarkdownWithCrossAccount(t *testing.T) {
	nodes := []ingest.Node{
		{
			ID:     "arn:aws:iam::111111111111:role/DevRole",
			Kind:   ingest.KindPrincipal,
			Labels: []string{"aws", "role"},
			Props:  map[string]string{},
		},
		{
			ID:     "arn:aws:iam::222222222222:role/TargetRole",
			Kind:   ingest.KindPrincipal,
			Labels: []string{"aws", "role"},
			Props:  map[string]string{},
		},
	}

	edges := []ingest.Edge{
		{
			Src:  "arn:aws:iam::111111111111:role/DevRole",
			Dst:  "arn:aws:iam::222222222222:role/TargetRole",
			Kind: "ASSUMES_ROLE",
			Props: map[string]string{
				"cross_account": "true",
			},
		},
	}

	markdown, err := ExportMarkdownAttackPath(
		"arn:aws:iam::111111111111:role/DevRole",
		"arn:aws:iam::222222222222:role/TargetRole",
		nodes,
		edges,
	)

	if err != nil {
		t.Fatalf("ExportMarkdownAttackPath failed: %v", err)
	}

	// Should detect cross-account access
	if !strings.Contains(markdown, "**Cross-account access**") {
		t.Error("Expected to detect cross-account access")
	}

	// Should show cross-account marker in notes
	if !strings.Contains(markdown, "[CROSS-ACCOUNT]") {
		t.Error("Expected [CROSS-ACCOUNT] marker in notes")
	}
}

func TestExportMarkdownEmpty(t *testing.T) {
	_, err := ExportMarkdownAttackPath("from", "to", nil, nil)
	if err == nil {
		t.Error("Expected error for empty nodes")
	}
}

func TestTruncateID(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "Short ID unchanged",
			input:    "short-id",
			expected: "short-id",
		},
		{
			name:     "Long ID truncated",
			input:    "arn:aws:iam::123456789012:role/very-long-role-name-that-exceeds-fifty-characters",
			expected: "arn:aws:iam::123456789012:role/very-long-role-n...",
		},
		{
			name:     "Exactly 50 chars unchanged",
			input:    "12345678901234567890123456789012345678901234567890",
			expected: "12345678901234567890123456789012345678901234567890",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := truncateID(tt.input)
			if result != tt.expected {
				t.Errorf("truncateID() = %q, want %q", result, tt.expected)
			}
		})
	}
}
